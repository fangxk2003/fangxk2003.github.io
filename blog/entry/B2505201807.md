---
layout: splash
---



## 背景

家教的孩子问了一道关于信息编码的游戏数学题，苦苦思索仅解决前两问，后通过多方渠道，明白了后两问。



## 题目原文

>  老师跟两位同学玩猜硬币的游戏，规则如下:
>
> 老师一队，甲、乙两位同学一队，进行若干局游戏。每一局游戏，老师、甲和乙都各自选择硬币正反面中的一面盖住，再同时亮出自己的硬币。如果这三枚硬币都是正面或都是反面，则本局同学方获胜。一场游戏由若干局组成，在一场游戏开始之后，甲和乙就不得再进行任何形式的交流了，他们能获知的信息只有每一局中三人硬币正反面的情况。
>
> 这个规则当然不利于同学，而且纯凭运气，没有什么趣味性。因此现在额外规定，在游戏开始后、第一局开始前增加一个环节,老师偷偷将自己接下来每一局要出什么全都告诉甲且老师必须如实执行。也就是说，同学甲从一开始就知道老师每一局要出什么。但此时游戏已经开始了，甲不能再跟乙进行任何交流，没法直接将老师的信息告知同学乙。
>
> 现在同学甲和同学乙决定充分利用这个额外规定,在游戏开始前他们有充足的时间想个最大化利用这个规定的策略。请帮助他们设计策略，保证同学方:
>
> 1. 在2局中赢1局
> 2. 在5局中赢3局
> 3. 在9局中赢6局
> 4. 在13局中赢9局



## 化归

需要在得分和提示后续的得分之间做到平衡。

$$A_i, B_i, C_i$$分别表示甲、乙和老师硬币正反$$(1\leq i \leq N)$$

甲的行为根据老师的信息改变：
$$
\vec{A}=F(\vec{C})
$$
乙的行为根据已知的结果与先前约定的规则改变：
$$
B_i=G(A_1,\dots,A_{i-1},C_1,\dots,C_{i-1})
$$
使得
$$
\min_{\vec{C}\in\{0,1\}^N}{\sum_{i=1}^N [A_i=B_i=C_i]}
$$
最大



同时函数F，G并不是线性的

以F为例，若是线性的，即
$$
\vec{A}_N=F_{N\times N} \vec{C}_N
$$
F有$2^{N^2}$种可能

若不是线性的，即F是一个$2^N$到$2^N$的映射，有$(2^N)^{2^N}=2^{N\times 2^N}$可能

是计算机难以枚举的量级



## 转载解法之一

来自 [蓬莱の魚の形](https://space.bilibili.com/208604)  的解法

原文：https://www.bilibili.com/read/readlist/rl305703

“是否获胜”和“是否传递信息” 这两个核心需求，是互斥的

### 5赢3策略

> 把5局分为1 + 3 + 1三组
>
> 甲先通过第一组告诉乙，第二组里比较多的颜色
>
> 乙在第二组里只出这个颜色，如果第二组颜色全相同，赢3，那么第三组无所谓，0+3+0=3
>
> 如果第二组颜色并不完全相同，则赢2输1，必输的那一局告诉乙，第三组的颜色是什么 0+2+1=3



为什么可以做到至少赢了一半多？这个方案**没有固定哪些局传递信息，哪些局必胜**

因此，234这组要赢2局，并没有使用2bit信息，而只使用了1bit，即第一组给的信息

可以发现一个重要技巧：**传递信息对一个范围做概括性描述，而不是精确描述某个特定情况。**

这个方案，可以轻松推广到3n+2局赢2n+1局



### 挖掘额外信息

1. 第一组故意传递第二组里较少的那个，这样第二组赢1输2，输的两局可以传递2bit信息
2. 第一组传递第二组里较多的那个，但是在本来应该赢的局里故意做错。因为本来应该赢两局，可以选前一局做错，也可以选后一局做错，根据故意错的先后可以传递1bit信息，加上本来必错的点，总共传递2bit信息

总结：

1. 想办法让必错的点变多，每个必错点能传递1bit信息
2. 把本来应该做对的点做错，根据故意做错点的位置传递信息

并且使用不同的方案本身就可以作为信息！

因为我们在1+3里可以做到

1. 告诉乙后续为分支一，赢1局，传递2bit信息 （策略1）
2. 告诉乙后续为分支二，赢1局，传递2bit信息 （策略2）
3. 告诉乙后续为分支三，赢2局，传递1bit信息 （常规做）



### 9赢6策略

> 将9局分为1+3+4+1的分组
>
> 看3那组的形状，如果这3局颜色完全一样
>
> > 则甲第一局提示这个颜色，后3局全赢
> >
> > 转化为后5局赢3局的子问题，这个子问题已经解决。
> >
> > 并且乙看到这3局全赢，也可以立刻知道后面该用5赢3的策略了。
>
> 如果这3局颜色不完全一样
>
> > 甲先看4那组的形状
> >
> > **如果是abba/baab**，则进入分支一：
> >
> > > 甲在第一组告诉乙第二组3局里较少的颜色，乙在第二组只出这个颜色
> > >
> > > 第二组会赢1输2，乙发现了甲故意告诉了乙较少的颜色，就明白这里是分支一，第三组颜色是abba/baab
> > >
> > > 而必输的两局，第一局甲用a表示第三组是abba，用b表示第三组是baab
> > >
> > > 第二局甲用a表示第四组是a，用b表示第四组是b
> > >
> > > 因此后5局全赢，总共0+1+4+1=6局
> >
> > **如果是abab/baba**，则进入分支二：
> >
> > > 甲在第一组告诉乙第二组3局里较多的颜色，乙在第二组只出这个颜色
> > >
> > > 第二组本来会赢2输1，但是甲在其中某一局故意做错。乙发现了甲故意做错，就明白这里是分支二，第三组颜色是abab/baba
> > >
> > > 如果靠前的那局故意做错，代表第三组是abab，如果靠后的那局故意做错，代表第三组是baba
> > >
> > > 本来必输的那局，甲用a表示第四组是a，用b表示第四组是b
> > >
> > > 因此后5局全赢，总共0+1+4+1=6局
> >
> > **如果是不平衡态/aabb/bbaa**，则进入分支三：
> >
> > > 甲在第一组告诉乙第二组3局里较多的颜色，乙在第二组只出这个颜色
> > >
> > > 第二组常规做，赢2输1，乙发现第二组赢2输1，就知道进入了分支三
> > >
> > > 必错的那局，根据第三组是否平衡分为两种情况
> > >
> > > **如果第三组不平衡**
> > >
> > > > 第二组必错的那局提示第三组较多的颜色。
> > > >
> > > > 乙在第三组只出这个颜色，如果是4:0，赢4局，总共已经赢了0+2+4=6局，最后一组无所谓了
> > > >
> > > > 如果是3:1，赢3局，必输的那局用来提示最后一组的那局颜色，如果是a就出a，是b就出b，保证那一局也胜利，总共0+2+3+1=6局
> > >
> > > **如果第三组平衡**
> > >
> > > > 第二组必错的那局提示第三组第一个，aabb就出a，bbaa就出b，但是乙现在还不知道
> > > >
> > > > 让乙先默认这组是不平衡态，先按照不平衡的方法出。因此前两个乙可以做对
> > > >
> > > > 但是甲在其中选一个位置故意做错提示乙这里是aabb/bbaa，乙一旦发现分支三里甲故意做错，就知道后两个要变色了，因此后两个可以做对，总共对3个。
> > > >
> > > > 而如果第一个故意做错，代表第四组是a，如果第二个故意做错，代表第四组是b，因此第四组也可以做对，总共0+2+3+1=6局



### 模块化

目前的结论：

1. 必输的局，每局可以传递1bit信息。
2. 固定需要赢的局数前提下，可赢的局，只能通过故意做错的位置传递C(n,r)种可能（传递log(C(n,r))bit信息）

我们将1+3当作一个模块begin()，功能（输出）如下：

1. 告诉乙是分支一，赢1局，获得2bit信息
2. 告诉乙是分支二，赢1局，获得2bit信息
3. 告诉乙是分支三，赢2局，获得1bit信息

我们将4+1当作一个模块end()，功能（输入）如下：

1. 需要乙知道是分支一，且使用掉2bit信息，赢5局
2. 需要乙知道是分支二，且使用掉2bit信息，赢5局
3. 需要乙知道是分支三，且使用掉1bit信息，赢4局

下面构造mid()，mid()内每一个输入分支下，输出的三个分支必须不能让乙混淆，甲必须给出足够信息让乙明确知道自己处于哪个输出分支。



### 13赢9（4n+1赢3n策略）

1->3->4->4->...->4->1

> in1（代表mid()形状为abba/baab）：
>
> > 输入了2bit信息。由于只有abba/baab的区别，于是只需要1bit即可区分。
> >
> > out3
> >
> > > 使用1bit信息，赢4局。
> > >
> > > 因为输入了2bit，只用了1bit，所以没用到的1bit信息作为out3的输出。
> > >
> > > 并且，in1里全胜，这个信息告诉乙后续是分支三（这里是out3）。
> >
> > out1/2
> >
> > > 我们先使用1bit信息区分abba/baab，然后可以在4个位置选择一个故意做错，这样赢了3局。
> > >
> > > 因为有4种可能，加上没用到的1bit输入，我们有3bit信息。可以使用1bit来区分到底是out1还是out2，剩下2bit作为out1或者out2的输出。
> > >
> > > 并且，in1里赢3输1，这个信息告诉乙这里是out1或2。
>
> in2（代表mid()形状为abab/baba）：
>
> >  输入了2bit信息，和in1完全同理，使用1bit区分abab/baba
> >
> > out3
> >
> > > 全部做对赢4局
> > >
> > > 没用到的1bit作为out3的输出。
> > >
> > > 并且，in2里全胜，这个信息告诉乙这里out3。
> >
> > out1/2
> >
> > > 4个位置故意选一个做错，赢3局，可以获得2bit信息，加上没用到的1bit，总共3bit作为out1/2的输出。
> > >
> > > 并且，in2里赢3输1，这个信息告诉乙这里是out1/2。
>
> in3（代表mid()形状为aabb/bbaa/不平衡态）：
>
> > 输入了1bit信息
> >
> > 如果4局颜色完全一样，则可以利用1bit信息直接全胜，加上begin(out3)里赢的2局，总共赢了6局，转化为后续5赢3的子问题，
> >
> > 这个子问题我们已经解决。但这种特例如果特殊处理则不便于推广，我们暂且把这个问题搁置一下，等到先解决了13赢9之后推广4n+1赢3n时再研究。
> >
> > 分为两种情况
> >
> > ①如果形状为aabb/bbaa
> >
> > > out3
> > >
> > > > 先使用输入的1bit信息来区分aabb/bbaa，乙则默认是不平衡态，只出a/b
> > > >
> > > > 甲在1或者2故意做错一局，提醒乙这里是平衡态，乙发现甲故意做错，后续两个就变色，可以全部做对，总共赢3局。
> > > >
> > > > 故意做错的一局可以是1也可以是2，因此能传递1bit信息作为out3的输出。
> > > >
> > > > 并且，甲在in3①里赢3输1，这个信息告诉乙这里是out3
> > >
> > > out1
> > >
> > > > 先使用输入的1bit信息来区分aabb/bbaa，乙则默认是不平衡态，只出a/b
> > > >
> > > > 甲在1或2故意做错一局，提醒乙这里是平衡态，乙发现甲故意做错，后续两个就变色。但是甲在后两局也选一局故意做错，总共赢2局。
> > > >
> > > > 故意做错的两局可以是13、14、23、24四种组合，因此能产生2bit信息作为out1的输出。
> > > >
> > > > 并且，甲在in3①里前两局故意错一局，后两局也故意错一局，这个信息告诉乙这里是out1。
> > >
> > > out2
> > >
> > > > 先使用输入的1bit信息来区分aabb/bbaa，乙则默认是不平衡态，只出a/b
> > > >
> > > > 甲在12都做对，因此乙并不知道后续要变色，所以34全错。总共赢2局。
> > > >
> > > > 乙虽然一直默认是不平衡态，以为这里是in3②，但4局结束后看到上帝是aabb/bbaa，依然可以明白这里是in3①。
> > > >
> > > > 必错的两局，甲可以自由分配，产生2bit信息作为out2的输出。
> > > >
> > > > 并且，甲在in3①里前两局做对，导致后两局做错，这个信息告诉乙这里是out2。
> >
> > ②如果是3比1的不平衡态
> >
> > > out3
> > >
> > > > 先使用输入的1bit信息来告诉乙哪种颜色比较多，乙只出这个颜色。可以赢3局。
> > > >
> > > > 必输的一局，可以产生1bit信息作为out3的输出
> > > >
> > > > 并且，甲在in3②里赢3输1，这个信息告诉乙这里是out3。
> > >
> > > out1/2（赢2输2，输出3bit）
> > >
> > > 1、如果将输入的1bit提示本组里较多的颜色
> > >
> > > > 乙先只出这个颜色
> > > >
> > > > 必错的局甲可以ab二选一
> > > >
> > > > 甲再从剩余3局选一局故意做错，总共赢2局
> > > >
> > > > 错局的位置有3种可能，加上必错局，总共可以分出6种情况。
> > > >
> > > > 根据具体情况乙后两局可能会误以为平衡态而变色，不过甲也会知道，不会影响策略。
> > >
> > > 2、如果将输入的1bit提示本组里较少的颜色（反常态）
> > >
> > > > 乙先只出这个颜色
> > > >
> > > > 若较少的颜色出现在后2局
> > > >
> > > > > 则乙会在必输掉前两局后发现这里是反常态
> > > > >
> > > > > 必输的两局甲可以自由分配产生2bit信息
> > > > >
> > > > > 其中1bit信息告知本组后两局是ab还是ba，保证后两局全赢，总共赢2局
> > > > >
> > > > > 另1bit信息可以是a也可以是b，分出2种情况
> > > >
> > > > 若较少的颜色出现在前两局
> > > >
> > > > > 则乙会在前三局一胜两负后发现这里是反常态
> > > > >
> > > > > 则最后一局可以获胜，总共赢2局
> > > > >
> > > > > 甲在必错的两局产生2bit信息，可以分出4种情况。
> > > > >
> > > > > 我们不需要这么多，只取其中2种情况
> > > > >
> > > > > 把“1、”里的6种情况与“2、”里的2种情况组合起来，总共有8种情况
> > > > >
> > > > > 可以产生3bit信息作为out1/2的输出。
> > > > >
> > > > > 并且，甲在in3②里赢2输2，这个信息告诉乙这里是out1/2



## 检索相关文献(half done)

[Oliver Gossner](https://scholar.google.fr/citations?user=WQs3TLcAAAAJ&hl=fr)

APA: Gossner, O., Hernández, P., & Neyman, A. (2006). Optimal use of communication resources. *Econometrica*, *74*(6), 1603-1636. https://doi.org/10.1111/j.1468-0262.2006.00720.x

文章地址: https://cris.huji.ac.il/en/publications/optimal-use-of-communication-resources

本地存档:  [Econometrica - 2006 - Gossner - Optimal Use of Communication Resources.pdf](B250520/Econometrica - 2006 - Gossner - Optimal Use of Communication Resources.pdf)

在 2.1 Example: Coordination with Nature 中给出了这个问题

### block size=3

具体如何得到
$$
\text{For } i=0: \quad
\begin{array}{c|cc}
 & 0 & 1 \\
\hline
0 & \frac{17}{48} & \frac{1}{16} \\
1 & \frac{1}{48} & \frac{1}{16} \\
\end{array}
\qquad
\text{For } i=1: \quad
\begin{array}{c|cc}
 & 0 & 1 \\
\hline
0 & \frac{1}{16} & \frac{1}{48} \\
1 & \frac{1}{16} & \frac{17}{48} \\
\end{array}
$$


## 代码仿真(half done)

```python
C = list(map(int, input().split()))
n = len(C)
assert n % 4 == 1 and n >= 9
                
def C_to_A_begin(C, t, info) :
    assert len(C) == 4
    a = sum(C[1:4])
    A = [0] * 4
    if a == 0 : return 0, [0] * 4
    if a == 3 : return 0, [1] * 4
    if a == 1 or a == 2:
        b = 2 - a
        id = C.index(b)
        if t == 1:
            A[0] = A[id] = b
            A[2 - (id >= 2)], A[3 - (id == 3)] = (info >> 1), (info & 1)
        if t == 2:
            A[0], A[id] = (b ^ 1), (info >> 1)
            A[2 - (id >= 2)], A[3 - (id == 3)] = b ^ (info & 1), b ^ (info & 1) ^ 1
        if t == 3:
            A = [b ^ 1] * 4
            A[id] = info
        return 1, A
    
def C_to_A_mid(M, t, info, tag):
    assert len(M) == 4
    m = M[0] * 8 + M[1] * 4 + M[2] * 2 + M[3]
    R = M.copy()
    T, INFO = 0, 0
    if tag : 
        t, A = C_to_A_begin(R, t, info)
    if m == 0b0110 or m == 0b1001 or m == 0b0101 or m == 0b1010:
        T = 2 - (M[0] ^ M[2])
        if t == 1 or t == 2:
            INFO = M[0] * 2 + t == 1
            R[info] ^= 1
        else :  INFO = M[0] * 2 + info
    else :
        T = 3
        s = sum(M)
        if m == 0b0011 or m == 0b1100:
            INFO = M[0]
            if t == 1 :
                R[info >> 1] ^= 1
                R[(info & 1) + 2] ^= 1
            if t == 2 : R[2], R[3] = (info >> 1), (info & 1)
            if t == 3 : R[info] ^= 1
        else :
            INFO = M[0]
            if t == 3 :

def C_to_A(C):
    b = C[-5] * 8 + C[-4] * 4 + C[-3] * 2 + C[-2]
    n = len(C)
    A = [0] * n
    A[-5:] = C[-5:]
    t, info = 0, 0
    if b == 0b0110 or b == 0b1001: t, info = 1, C[-5] * 2 + C[-1]
    elif b == 0b0101 or b == 0b1010: t, info = 2, C[-5] * 2 + C[-1]
    else :
        c = sum(C[-5:-1])
        t, info = 3, C[-5]
        if b == 0b0011 or b == 0b1100:
            if C[-1] == 0: A[-5] ^= 1
            else : A[-4] ^= 1
        elif c == 1 or c == 3: A[C[-5:-1].index(c == 1) - 5] = C[-1]
    for i in range((n - 9) // 4, 0, -1):
        A[i * 4:i * 4 + 4], t, info = C_to_A_mid(C[i * 4:i * 4 + 4], t, info, i > 1 and sum(C[i * 4 - 4:i * 4]) == 4)

```



